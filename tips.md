# Tips

## 1. Care About Your Craft
There is no point in developing software unless one cares about doing it well.

## 2. Think! About Your Work
Don't just do. Stop and think about what you are doing. Critique and appraise your work as you go.

## 3. Provide Options, Don't Make Lame Excuses
Never say that something can't be done. Instead, come up with options of how it *can* be done.

## 4. Don't Live with Broken Windows
Don't let broken windows exist in code (bad design, poor code, etc). Either fix the window or board it up until it can be fixed.

## 5. Be a Catalyst for Change
Change cannot be forced upon other people, but it can be shown. Try and let other people see how change can be accomplished and let others follow suit.

## 6. Remember the Big Picture
Try to keep an eye on the big picture. Always check what is going on around you.

## 7. Make Quality a Requirements Issue
Invovle your users in determining the project's real quality requirements.

## 8. Invest Regularly in Your Knowledge Portfolio
As programmers, our knowledge is our biggest asset. It should be improved upon *every* day that we exist. Make learning a daily habit.

## 9. Critically Analyze What You Read and Hear
Everything that enters your head should be filtered and compared to what you already know. Don't just take things *as is*, make sure it's right.

## 10. It's Both What You Say and How You Say It
Content is only half of it. Having an idea and communicating it effectively is just as important.

## 11. DRY -- Don't Repeat Yourself
...

## 12. Make It Easy to Reuse
To keep up with the DRY principle, make things with others in mind.

## 13. Eliminate Effects Between Unrelated Things
When designing things, keep them independent which will make them easier to use.

## 14. There Are No Final Decisions
Nothing should be set in stone.

## 15. Use Tracer Bullets to Find the Target
Use tracer bullets in code to hone in on your target. Being close gives more advantages than not knowing where your target is.

## 16. Prototype to Learn
The code doesn't matter. The only thing that matters is that you learn how something works.

## 17. Program Close to the Problem Domain
Coding at a higher level of abstraction leaves you able to concentrate on solving domain problems.

## 18. Estimate to Avoid Surprises
Making a thorough and accurate estimate on a project can help spot problems up front.

## 19. Iterate the Schedule with the Code
Make adjustments as you go to keep the schedule as accurate as possible.

## 20. Keep Knowledge in Plain Text
Simpler is always better.

## 21. Use the Power of Command Shells
Utilize the tools you have to do you best work.

## 22. Use a Single Editor Well
In other words, learn VIM really well ;)

## 23. Always Use Source Code Control
This is a must for any serious developer.

## 24. Fix the Problem, Not the Blame
Blaming someone for a bug is pointless, rather than doing that, just fix it.

## 25. Don't Panic
In the spirit of Douglas Adams, this belongs on any list ;)

## 26. "select" Isn't Broken
Basically the bug most likely resides in your code, not the OS, compiler, or third party libraries.

## 27. Don't Assume It--Prove It
Prove your assumptions in the actual environment--with real data and boundary conditions.

## 28. Learn a Text Manipulation Language
You spend a large part of each day working with text. Why not have the computer do some of it for you?

## 29. Write Code That Writes Code
Code generators increase your productivity and help avoid duplication.

## 30. You Can't Write Perfect Software
Software can't be perfect. Protect your code and users from the inevitable errors.

## 31. Design with Contracts
Use contracts to document and verify that code does no more and no less that it claims to do.

## 32. Crash Early
A dead program normally does a lot less damage than a crippled one.

## 33. Use Assertios to Prevent the Impossible
Assertions validate your assumptions. Use them to protect your code from an uncertain world.

## 34. Use Exceptions for Exceptional Problems
Exceptions can suffer from all the readability and maintainability problems of classic spaghetti code. Reserve exceptions for exceptional things.

## 35. Finish What You Start
Where possible, the routine or object that allocates a resource should be responsible for deallocating it.

## 36. Minimize Coupling Between Modules
Avoid coupling by writing "shy" code and applying the Law of Demeter.

## 37. Configure, Don't Integrate
Implement technology choices for an application as configuration options, not through integration or engineering.

## 38. Put Abstractions in Code, Details in Metadata
Program for the general case, and put the specifics outside the compiled code base.

## 39. Analyze Workflow to Improve Concurrency
Exploit concurrency in your user's workflow.

## 40. Design Using Services
Design in terms of *services*--independent, concurrent objects behind well-defined, consistent interfaces.

## 41. Always Design Concurrency
Allow for concurrency, and you'll design cleaner interfaces with fewer assumptions.

## 42. Separate Views from Models
Gain flexibility at low cost by designing your application in terms of models and views.

## 43. Use Blackboards to Coordinate Workflow
Use blackboards to coordinate disparate facts and agents, while maintaining independence and isolation amont participants.

## 44. Don't Program by Coincidence
Rely on reliable things. Beware of accidental complexity, and don't confuse a happy coincidence with a purposeful plan.

## 45. Estimate the Order of Your Algorithms
Get a feel for how long things are likely to take before you write code.

## 46. Test Your Estimates
Mathematical analysis of algorithms doesn't tell you everything. Try aiming your code in its target environment.

## 47. Refactory Early, Refactor Often
Just as you might weed and rearrange a garden, rewrite, rework, and re-architect code when it needs it. Fix the root of the problem.

## 48. Design to Test
Start thinking about testing before you write a line of code.

## 49. Test Your Software, or Your Users Will
Test ruthlessly. Don't make your users find bugs for you.

## 50. Don't Use Wizard Code You Don't Understand
Wizards can generate reams of code. Make sure you understand *all* of it before you incorporate it into your project.

## 51. Don't Gather Requirements--Dig for Them
Requirements rarely lie on the surface. They're buried deep beneath layers of assumptions, misconceptions, and politics.

## 52. Work with a User to Think Like a User
It's the best way to gain insight into how the system will *really* be used

## 53. Abstractions Live Longer than Details
Invest in the abstraction, not the implementation. Abstractions can survive the barrage of changes from different implementations and new technologies.

## 54. Use a Project Glossary
Create an maintain a single source of al the specific terms and vocabulary for a project.

## 55. Don't Think Outside the Box--*Find* the Box
When faced with an impossible problem, identify the *real* constraints. Ask yourself: "Does it have to be done this way? Does it have to be done at all?"

## 56. Start When You're Ready
You've been building experience all your life. Don't ignore niggling doubts.

## 57. Some Things Are Better Done than Described
Don't fall into the specification spiral==at some point you need to start coding.

## 58. Don't Be a Slave to Formal Methods
Don't blindly adopt any technique without putting it into the context of your development practices and capabilities.

## 59. Costly Tools Don't Produce Better Designs
Beware of vendor hype, industry dogma, and the aura of the price tag. Judge tools on their merits.
